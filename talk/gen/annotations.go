package gen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

var talkAnnotationRegex = regexp.MustCompile(`@talk\s+(.*)`)

type AnnotationInfo struct {
	MethodName string
	Annotation string
}

type ServiceAnnotations struct {
	PackageName  string
	ReceiverType string
	Annotations  []AnnotationInfo
}

func GenerateAnnotations(sourceFile, typeName, outputFile string) error {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, sourceFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("parse file: %w", err)
	}

	sa := &ServiceAnnotations{
		PackageName:  f.Name.Name,
		ReceiverType: typeName,
	}

	ast.Inspect(f, func(n ast.Node) bool {
		fn, ok := n.(*ast.FuncDecl)
		if !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {
			return true
		}

		recvType := extractReceiverType(fn.Recv.List[0].Type)
		if recvType != typeName && recvType != "*"+typeName {
			return true
		}

		if fn.Doc == nil {
			return true
		}

		for _, comment := range fn.Doc.List {
			text := strings.TrimPrefix(comment.Text, "//")
			text = strings.TrimPrefix(text, "/*")
			text = strings.TrimSuffix(text, "*/")
			text = strings.TrimSpace(text)

			if match := talkAnnotationRegex.FindStringSubmatch(text); match != nil {
				sa.Annotations = append(sa.Annotations, AnnotationInfo{
					MethodName: fn.Name.Name,
					Annotation: "@talk " + strings.TrimSpace(match[1]),
				})
				break
			}
		}

		return true
	})

	if len(sa.Annotations) == 0 {
		return nil
	}

	code, err := generateAnnotationsCode(sa)
	if err != nil {
		return err
	}

	if outputFile == "" {
		ext := filepath.Ext(sourceFile)
		outputFile = strings.TrimSuffix(sourceFile, ext) + "_talk_annotations.go"
	}

	return os.WriteFile(outputFile, code, 0644)
}

func extractReceiverType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			return "*" + ident.Name
		}
	}
	return ""
}

var annotationsTemplate = `// Code generated by talk gen; DO NOT EDIT.

package {{.PackageName}}

func (s *{{.ReceiverType}}) TalkAnnotations() map[string]string {
	return map[string]string{
{{- range .Annotations}}
		"{{.MethodName}}": "{{.Annotation}}",
{{- end}}
	}
}
`

func generateAnnotationsCode(sa *ServiceAnnotations) ([]byte, error) {
	tmpl, err := template.New("annotations").Parse(annotationsTemplate)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, sa); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}
